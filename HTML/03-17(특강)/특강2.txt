레이아웃의 핵심

컨테치닝 블록 : 부모가 제공해주는 컨텐츠 영역

이렇게 하지말고 간단한게 있는데 왜 하냐?
css를 만드는 방법은 다양하다! 다양한 방법을 알고 있으면 잘 쓸 수있다.

1. negative-margin (음수마진)
마진공부
제일 마지막에 선택된 것이 맨 앞으로 배치됨
margin 0(초기값) : 차지하고 있는공간과 디자인이 그대로 같다
margin은 차지하고 있는 공간(마진값 준 만큼)과 보여지고 있는 디자인(원래 이미지 크기) 공간은 별개이다.

margin은 마이너스 값이 가능하다! (이러한 기법은 버그가 아닌 많이들 씀 브라우저를 속이는 용도, 하지만 적재적소에 사용해야 한다.)
margin-top : -50px -> 차지하고 있는 공간이 정수리 기준에서 깎임, 하지만 보여지는 크기(비주얼)는 그대로
margin-bottom : -50px -> 이미지 크기는 그대로인데, 차지하고 있는 공간을 없앰에 따라 뒤따라오는 밑의 텍스트가 올라옴 
margin-left: 50px -> 차지하고 있는 공간이 오른쪽으로 50px 늘어나지만 보이는 공간은 그대로
margin-left: -50px, margin-right: -50px -> 둘다 주면 앞의 요소의 위에 뒤의 요소의 뒤로 중간에 겹친다.

width: auto 부모의 컨테이너블록의 너비이다 (부모가 패딩을 준경우 패딩값을 준 값이다.)
width: 400px인 상태에서 padding: 50px을 주면 width값이 500이 된다.
여기서 패딩 왼쪽값이 보기가 불편하다. 이때 negative-margin을 사용한다.
margin-left: -50px; 이때 보여지는 부분은 그대로지만, 왼쪽 -50px을 뺀 값은 껍데기다.
그리고 margin-right: -50px; 주면 오른쪽에 사용할 수 있는 공간(50px)은 늘어나지만 실제로 보여지는 부분은 다른게 없다. (뒤따라오는 컨텐츠가 없기 때문)
width값을 고정값이 아닌 auto값을 주면 부모의 컨테이너블록의 너비로 되기때문에 크기가 커진다. 이때 껍데기도 같이 커진다.
좌우로 마이너스값을 마진값을 준다면 차지하고 있는 공간은 같으나 보여지는 공간은 다르게 보여줄 수 있다.(껍데기도 같이 커지기 때문)
그래서 크게보이게 할 수있다.  margin: 40px -150px; (단축속성)

컨테이닝 블록의 전체 너비, 패딩이나 마진값을 더해주면 자동적으로 계산하여 다 차게함.
블록요소의 초기값으로 자동설정
width: auto
컨테이닝 블록의 너비의 백분율, 패딩이나 마진값을 더해주면 그냥 더해져서 오버될 수 있음
width: 100% 는 마진, 패딩, 보더 영역을 다 포함한 값으로 나옵니다. 이때 box-sizing: border-box 가능
width: %

position
z-index와 마크업 순서가 상관없이
position: static이 아닌 값을 넣으면 맨앞으로 나옴
네거티브 마진을 쓰면 뒤의 요소가 뒤따라 나옴
transform으로 위치를 바꾸면 차지하는 공간은 그대로지만, 보여지는 공간이 다르게 보임
position:
1. static : 초기값
2. relative: 기본적으로 마크업 순서와 상관없이 더 먼저 나옴
relative는 상대적인 위치로 자기가 주도권이 없는 주위 환경에 상대적으로 변함 기존 그 요소의 자리
left:0 top:0 -> 안움직임 기본값
3. absolute: 공중에 뜸 뒤따라오는 요소는 그 밑에 숨어버림.
left: auto, top: auto -> 현재 내 위치에서 뛰기만함 기본값
left:0 top:0 을 하면 뷰포트(전체 창 기준)의 좌측상단으로 간다.
(스크롤에 의해 내려갈 경우는 고정이 되지 않고(창을 줄일경우는 움직이긴함) 처음 뷰포트에 있는다
고정 시키고 싶으면 fixed를 씀)
absolute 상태에게 컨테이닝 블록주는 것은 뷰포트이다.
이때 직계부모에게 position: static이 아닌 요소를 부여하면 absolute 상태에 컨테이닝 블록을 받을 수 있다.
자기기준에서 상위로 올라가서 position: static이 아닌 값으로 받고 있다면 바로 컨테이닝 블록을 받는다 (먼저 받는 순으로 됨)
left: 50%;
top: 50%;
transform: translate(-50%, -50%);
가운데 정렬

margin-left: -50px;
margin-top: -50px;
이것또한 가운데 정렬이 된다 마이너스된 값만큼 차지하고 있는 공간을 없애고, 보이는 공간은 그대로 하지만 px값으로 되어있기 때문에 부모값이 달라지면 가운데가 아니게 된다.

left: 0, right: 0 을주면 컨테이너 블록의 너비만큼 다 차지함 (left, right 둘다 사용가능한 공간으로 지정)
이것은 width: auto랑 같음
width: 100px, left: 0 만 주고 margin: 0 auto를 주면 가운데 정렬이 되지 않음, right: 0을 주지않으면 오른쪽에 사용가능한 공간이 없기 때문

left: 0;
top: 0;
right: 0;
bottom: 0; 다 쓸경우 가득 채운다. -> 단축속성: inset: 0;
이때 inset: 10px을 하면 margin: 10px 같은 효과
inset: -10px하면 원래 크기보다 더 커진다. -> negative margin과 같은 효과

가상요소 : 수도엘리먼츠

flexbox
flex는 부모요소에게 display: flex를 준다.
flex container -> 부모 (display: flex)가 자식을 위치한다.
flex items -> 자식
/* 사용가능한 공간을 왼쪽으로 보내겠다 */
margin-left: auto;
/* 사용가능한 공간을 좌우로 보내겠다 */
margin: auto;

flex-items(flex된 부모의 자식)은
flex-grow: 1; -> flex-basis: auto 에 grow 값을 더한다.
flex-grow: 1을 안의 요소 모두에게 줬을 때, flex-basis 값에 grow값을 줬기 때문에 완벽하게 나눠지는게 아니라 더한 값으로 나오기 때문에
더한 값으로 나눠진다.

flex-basis: 200px 은 각 요소에 200px의 방을 준다.
이때 부모의 값을 넘어버리면 요소값(200px)이 줄어든다(부모값은 그대로). (기본적으로 shrink: 1 이 있기 때문)
자식 중 하나만 shrink: 0을 주면 그 하나만 200px 그대로 받는다.

요소를 더 많이 계속 주게되면 삐져나온다. 이런 경우는
자신의 너비가 내부 자식 크기보다 더 작아질 수 없게 자식의 최소사이즈 만큼 강제하는 프로퍼티로
min-width: auto인데 자동으로 있음 이 값을 min-width: 0으로 바꾸면 내부 자식 크기를 무시하고 사용할 수 있다.

*과제에서 그림 옆의 컨텐트값 등을 min-width: 0을 줘서 내부 자식요소가 튀어나오든 고정하게 만든다.

이때부터는 부모에게 justify-content(주축) 를 주는 것처럼 부모에게 flex 속성을 준다.
(내 예상보다 flex-items 값들이 더 안작아지네? min-width값이 auto라 그렇다 라는식으로 공부)

flex-items인 자식 하나가 height가 커지면 부모가 커지는데, 이때 다른 자식들도 커진다.
-> align-items(교차축): stretch 가 기본적으로 있기 때문이다. (늘어난다는 속성)
자 이제 자식들을 가운데로 옮기고 싶다. -> margin: auto 0 ; 가능 -> 마진은 만능이다.

flex-direction: row-reverse; 을 쓰면 마크업 순서는 있지만 보이는 부분을 다르게 할 수 있다.
(nth-child(even))을 줘서 짝수마다 다르게 주는 것