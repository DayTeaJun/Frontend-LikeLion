// 전개 구문
// 배열의 전개 구문
const 과일들 = ['사과', '파인애플', '수박'];
const 생선들 = ['조기', '갈치', '다금바리'];
const 합치면 = [...과일들, ...생선들];
const 합치면2 = [과일들, 생선들];

console.log(합치면);
// ['사과', '파인애플', '수박', '조기', '갈치', '다금바리']
console.log(합치면2);
// [Array(3), Array(3)]
// 0 : (3) ['사과', '파인애플', '수박']
// 1 : (3) ['조기', '갈치', '다금바리']
// length : 2

// 객체의 전개 구문
const 위니브1 = { 개리: 1, 빙키: 2 };
const 위니브2 = { 라이캣: 3 };
const 위니브3 = { ...위니브1, ...위니브2 };

console.log(위니브3);

const 위니브임직원 = { // 옛날 데이터라고 가정
    개리: '재직중',
    빙키: '재직중',
    라이켓: '재직중',
    뮤라: '재직중',
    해골왕: '재직중'
};

const 위니브임직원2 = { // 새로운 데이터로 업데이트
    ...위니브임직원, // 배열의 전개 구문처럼 객체 전개 구문 역시 기존 객체를 복사해 완전히 새로운 값을 할당할 수 있음
    라이켓: '휴가',
    해골왕: '퇴사'
};
// 전개되는 객체들 중에 같은 이름의 key가 있다면, key 의 값은 나중에 온 객체의 키값으로 업데이트 할 수 있음

const 위니브임직원3 = { // 위의 위니브임직원과 다른 데이터를 가리킴
    ...위니브임직원
};

위니브임직원 // 값 변동없이 그대로임

// 구조분해할당
for (const [i, j] of [[1, 2], [3, 4], [5, 6]]) {
    console.log(i, j)
}

const 위니브임직원4 = {
    개리: '재직중',
    빙키: '재직중',
    라이켓: '재직중',
    뮤라: '재직중',
    해골왕: '재직중'
};
Object.entries(위니브임직원4)

for (const [i, j] of Object.entries(위니브임직원4)) {
    console.log(i, j)
}

let [a, b] = [10, 20]
// let [one, two, three] = '010-5044-2903'.split('-')
let [one, two, ...three] = '010-5044-2903-123-123'.split('-')


///////////////////////////////

const test1 = [
    [1, 2, [10, 20]],
    [3, 4, [30, 40]],
    [5, 6, [50, 60]]
]
for (const [i, j, k] of test1) {
    console.log(i, j, k)
}

const test2 = [
    [1, 2, [10, 20]],
    [3, 4, [30, 40]],
    [5, 6, [50, 60]]
]
for (const [i, j, k] of test2) {
    console.log(i, j, k);
}

const test3 = [
    [1, 2, [10, 20]],
    [3, 4, [30, 40]],
    [5, 6, [50, 60]]
]
// i, j, k, l, m, n
for (const [i, j, [k, l]] of test3) {
    console.log(i, j, k, l)
}

// 이건 기억하셈
const test4 = [
    [1, 2, 10, 20],
    [3, 4, 30, 40],
    [5, 6, 50, 60]
]
// i, j, k, l, m, n
for (const [i, j, ...k] of test4) { // 전개구문 ...k로 나머지를 호출함
    console.log(i, j, k)
}

function hello(a, b, ...c) {
    console.log(a, b, c)
}

hello(1, 2, 3, 4, 5, 6, 7)

// 4월 12일 추가
Math.max(...[10, 20, 30]) // 전개해야 된다.
Math.min(...[10, 20, 30])
Math.max(...[10, 20, 30, [11, 12, 13, [29, 40, 50]]].flat(Infinity))

// 오류나는코드
Math.max([10, 20, 30])
Math.max([10, 20, 30, [11, 12, 13, [29, 40, 50]]]) // error 전개, flat 해야됨
Math.max(...[10, 20, 30, [11, 12, 13, [29, 40, 50]]].flat(Infinity)) // 전개구문하고 flat(Infinity안에 내용 전부 펼치기)을 해서 Max 메서드 사용

// 자주 사용하는 코드
const s = 'hello world';
[s] // s.split()과 비슷함
[...s] // s.split()과 비슷함
// {...s} 이렇게 전개할 이유는 없음 실무에서도 안씀